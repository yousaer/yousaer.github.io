<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yousaer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yousaer.top/"/>
  <updated>2019-11-15T02:16:49.601Z</updated>
  <id>http://yousaer.top/</id>
  
  <author>
    <name>yousaer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>目标文件</title>
    <link href="http://yousaer.top/2019/11/15/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/"/>
    <id>http://yousaer.top/2019/11/15/目标文件/</id>
    <published>2019-11-15T02:04:35.000Z</published>
    <updated>2019-11-15T02:16:49.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标文件格式目标文件格式"><a href="#目标文件格式目标文件格式" class="headerlink" title="目标文件格式目标文件格式"></a>目标文件格式目标文件格式</h2><p>编译器编译源代码以后生成的文件叫做目标文件。<br>目标文件从结构上讲，它已经是编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没被调整。其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍微有些不同。</p><p>pc平台流行的<strong>可执行文件格式（Executable）</strong>主要是Windows下的<strong>PE（Portable Executable）</strong>和Linux的<strong>ELF（Executable linkabel Format）</strong><br>它们都是<strong>COFF（Common file fomat）</strong>格式的变种<br>目标文件就是源代码编译后但未进行链接的那些中间文件（Windows的.obj和Linux下的.o）</p><p>在Windows下我们可以统称它们为<strong>PE-COFF文件格式</strong><br>在Linux下我们可以统称他们为<strong>ELF文件</strong><br>其他不太常见的可执行文件格式：intel/microsoft的OMF（Object Module Format）、Unix a.out格式和MS-DOS .COM等</p><p><strong>动态链接库(DLL,Dynamic Linking Library)</strong>(Windows的.dll和Linux的.so)<strong>及静态链接库(Static Linking Library)</strong>(Windows的.lib和Linux的.a)都可以按照可执行文件格式存储<br>静态链接库稍有不同，它把很多目标文件捆绑在一起形成一个文件，再加上一些索引，可以简单的理解为一个包含有很多目标文件的文件包。</p><table><thead><tr><th align="center">ELF文件类型</th><th align="center">说明</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">可重定位文件(Relocation File)</td><td align="center">这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类</td><td align="center">Linux的.o</td></tr><tr><td align="center">Windows的.obj</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">可执行文件(Executable File)</td><td align="center">这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，它们一般都没有扩展名</td><td align="center">比如/bin/bash文件</td></tr><tr><td align="center">Windows的.exe</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">共享目标文件(Shared Object File)</td><td align="center">这种文件包含了代码和数据，可以在以下两种情况下使用。一种是连接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行</td><td align="center">Linux的.so，如/lib/glibc-2.5.so</td></tr><tr><td align="center">Windows的DLL</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">核心转储文件(Core Dump File)</td><td align="center">当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件</td><td align="center">Linux下的Core dump</td></tr></tbody></table><p>Linux下可以用file命令来查看相应的文件格式</p><h2 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h2><p>目标文件中的内容至少有编译后的机器指令代码、数据。除了这些内容以外，目标文件中还包括了链接时所需要的一些信息，比如符号标、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以<strong>“节”(Seciton)</strong>的形式存储，有时候也叫<strong>“段”(Segment)</strong>,在一般情况下，它们都表示一个一定长度的区域，基本上加以区别，唯一区别是在<strong>ELF</strong>的链接视图和装载视图的时候。默认统一叫段</p><p>程序源代码编译后的机器指令进程被放在<strong>代码段(Code Section)</strong>里，代码段常见的名字有”.code”或”.text”<br>已初始化的全局变量和局部静态变量数据经常放在<strong>数据段(Data Section)</strong>，数据段的一般名称都叫”.data”<br><strong>未初始化的全局变量和局部静态变量一般放在一个叫”.bss”的段里，只是为了预留位置而已</strong></p><p><strong>只读数据段（.rodata）、注释信息段（.comment）和堆栈提示段（.note.GUN-statck）</strong></p><p><strong>总体来说，程序源代码被编译以后主要分成两种段：程序指令和程序数据。代码段属于程序指令。而数据段和.bss段属于程序数据。</strong></p><p>ELF文件开头是一个”文件头“(File Header)，它描述了整个文件的文件属性，还包括一个段表(Section Table)，段表其实是一个描述文件中各个段的数组</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目标文件格式目标文件格式&quot;&gt;&lt;a href=&quot;#目标文件格式目标文件格式&quot; class=&quot;headerlink&quot; title=&quot;目标文件格式目标文件格式&quot;&gt;&lt;/a&gt;目标文件格式目标文件格式&lt;/h2&gt;&lt;p&gt;编译器编译源代码以后生成的文件叫做目标文件。&lt;br&gt;目标文件
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>信息收集</title>
    <link href="http://yousaer.top/2019/11/14/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://yousaer.top/2019/11/14/信息收集/</id>
    <published>2019-11-14T11:54:29.000Z</published>
    <updated>2019-11-14T12:03:58.245Z</updated>
    
    <content type="html"><![CDATA[<p>whois查询：whoisdignslookup<br>ip定位：<a href="http://www.ip2location.com,www.maxmind.com,www.cz88.net,http://www.chaipip.com/" target="_blank" rel="noopener">www.ip2location.com,www.maxmind.com,www.cz88.net,http://www.chaipip.com/</a><br>网站信息查询：searchdns.netcraft.com,<a href="https://toolbar.netcraft.com/site_report" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report</a><br>IP2domain反向查询：<a href="https://www.ip-address.com/reverse-ip-lookup" target="_blank" rel="noopener">https://www.ip-address.com/reverse-ip-lookup</a></p><p>google hacking<br>|——特定目录<br>|——特定文件夹<br>|——注入点</p><p>metasploit平台工具<br>|——brute_dirs<br>|——dir_listing<br>|——dir_scanner<br>|——search_email_collector</p><p>搜索引擎<br>google常见语法：site：、inurl：、intext：、filetype：<br>shodan引擎<a href="http://www.shodan.io：" target="_blank" rel="noopener">www.shodan.io：</a> 搜索物联网设备</p><p>Shodan语法<br>|hostname——搜索指定的主机或域名，例如 hostname：baidu<br>|port————搜索指定的端口或服务，例如 port：80<br>|country——–搜索指定的国家，例如 country：US<br>|city————-搜索指定的城市，例如 city：Changsha<br>|org————-搜索指定的组织或公司，例如 org：”Google”<br>|isp————–搜索指定的ISP供应商，例如 isp：”China Telecom”<br>|product——–搜索指定的操作系统/软件/平台，例如 product：”Apache httpd”<br>|version———搜索指定的软件版本，例如 version：”1.6.2”<br>|geo————-搜索指定的地理位置，参数为经纬度，例如 geo：”31.8639，117.2808”<br>|before/after—-搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before：”11-11-15”<br>|net————–搜索指定的IP地址或子网，例如 net：”210.45.240.0/24”</p><p>主机查询<br>ping/tracert、arp-scan、nmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Nmap</span><br><span class="line">-sn，只检查是否服务器响应ICMP请求</span><br><span class="line">-sV，请求每个被发现的开放端口的标识</span><br><span class="line">-O，尝试猜测运行在目标上的操作系统</span><br><span class="line">-sT,强制执行完全连接扫描，会留日志且慢，但不太容易被入侵检测系统检测到</span><br><span class="line">-Pn、跳过ping测试</span><br><span class="line">-p、指定测试特定端口</span><br><span class="line">-v、开启详细模式，次数越多越详细（-vv、-v -v -v）</span><br><span class="line">--script=scripte_name、使用脚本进行查询， https://nmap.org/nsedoc/scripts/有需要的脚本</span><br><span class="line">例如检测WAF的存在</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 80，443 --script=http-waf-detect 192.168.1.1</span><br><span class="line">//检测是否有WAF存在</span><br><span class="line">nmap -p 80,443 --script=http-waf-fingerprint 192.168.1.1</span><br><span class="line">//检测是服务器存在WAF的型号</span><br></pre></td></tr></table></figure><p>其他工具例如 wafw00f 也可以检测WAF</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;whois查询：whoisdignslookup&lt;br&gt;ip定位：&lt;a href=&quot;http://www.ip2location.com,www.maxmind.com,www.cz88.net,http://www.chaipip.com/&quot; target=&quot;_blank
      
    
    </summary>
    
    
      <category term="渗透" scheme="http://yousaer.top/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Start</title>
    <link href="http://yousaer.top/2019/08/14/Start/"/>
    <id>http://yousaer.top/2019/08/14/Start/</id>
    <published>2019-08-14T06:56:09.000Z</published>
    <updated>2019-08-14T07:12:17.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我又回来了！！！！！"><a href="#我又回来了！！！！！" class="headerlink" title="我又回来了！！！！！"></a>我又回来了！！！！！</h1><h2 id="真的是不喜欢搞这些花里胡哨的东西"><a href="#真的是不喜欢搞这些花里胡哨的东西" class="headerlink" title="真的是不喜欢搞这些花里胡哨的东西"></a>真的是不喜欢搞这些花里胡哨的东西</h2><p>mk文档又不会写，每次弄还得边查用法<br>只不过回来就好好弄吧<br>得把一堆笔记往上传了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我又回来了！！！！！&quot;&gt;&lt;a href=&quot;#我又回来了！！！！！&quot; class=&quot;headerlink&quot; title=&quot;我又回来了！！！！！&quot;&gt;&lt;/a&gt;我又回来了！！！！！&lt;/h1&gt;&lt;h2 id=&quot;真的是不喜欢搞这些花里胡哨的东西&quot;&gt;&lt;a href=&quot;#真的是不喜
      
    
    </summary>
    
    
  </entry>
  
</feed>
